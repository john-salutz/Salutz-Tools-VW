{//////////////////////////////////////////////////////////////////////////////
//  Developed by John Salutz, (c) 2020. Please share freely.
//
//  SBD Line draws a dynamic polyline with midpoint control & markers.
//////////////////////////////////////////////////////////////////////////////}

{//////////////////////////////////////////////////////////////////////////////
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//  <https://www.gnu.org/licenses/>
//////////////////////////////////////////////////////////////////////////////}

PROCEDURE SBD_Line;

CONST
	RGBmax = 65535; {Max value for setting RGB colors in VS fuctions}
	RegularH = 12;
	SmallH   = 9;
	MicroH = 6;

VAR
	{Standard variables}
	s_ObjName                                               : STRING;
	h_Obj,h_ObjRecord,h_ObjWall                             : HANDLE;
	b_Result                                                : BOOLEAN;
	i_Counter                                               : INTEGER;
	{Script specific variables}
	pt1,pt2                                                 : POINT;
	p_Start,p_StartCorner,p_Midpoint,p_EndCorner,p_End      : POINT;
	h_Poly                                                  : HANDLE;
	r_CornerSize,r_test                                     : REAL;
	i_CornerStyle,i_FlipX1,i_FlipX2                         : INTEGER;
	i_BegDupSize,i_EndDupSize                               : INTEGER;

{===== LOCAL FUNCTION DECLARATIONS =====}

{// Sets Version info parameter //}
PROCEDURE Set_Version_Info(s : STRING);
BEGIN
	SetRField(h_Obj,s_ObjName,'ver',s);
END;


{// Sets the specified text object to use the attributes of PIO //}
PROCEDURE Use_PIO_Text_Attributes (h : HANDLE);
BEGIN
	SetObjectVariableBoolean(h,800,True);
END;

{// Sets Background Fore and Back as White to Black, percentage set by 'r',
format 0=White, 0.1 thru 0.9=10% to 90%, 1=Black //}
PROCEDURE Set_Background_WtoB (h : HANDLE; r : REAL);
VAR i : LONGINT;
BEGIN
	IF r<0 THEN r:=0;
	IF r>1 THEN r:=1;
	i := Trunc(RGBmax*(1-r));
	SetFillBack(h, i, i, i);
	SetFillFore(h, i, i, i);
	SetFPat(h, 1); {Blank pattern}
END;

{// Sets Pen Fore and Back as White to Black, percentage set by 'r',
format 0=White, 0.1 thru 0.9=10% to 90%, 1=Black //}
PROCEDURE Set_Pen_WtoB (h : HANDLE; r : REAL);
VAR i : LONGINT;
BEGIN
	IF r<0 THEN r:=0;
	IF r>1 THEN r:=1;
	i := Trunc(RGBmax*(1-r));
	SetPenFore(h, i, i, i);
	SetPenBack(h, i, i, i);
	SetLSN(h,2); {Solid pattern}
END;

FUNCTION Find_Layer (obj : HANDLE) : HANDLE;
BEGIN
	IF GetLayer(obj) = NIL THEN ResetObject(obj)
	ELSE Find_Layer := GetLayer(obj);
END;

PROCEDURE Resolve_MidPoint_Conflict;
VAR
	matchPoint,matchField : BOOLEAN;
	correctValue          : STRING;
BEGIN
	matchPoint := (P__STOREMIDPOINTDIST = Num2StrF(PCONTROLPOINT02X));
	matchField := (P__STOREMIDPOINTDIST = Num2StrF(PMIDPOINTDIST));
	correctValue := '';
	IF matchPoint AND NOT matchField THEN BEGIN
		{Field correct, set value from field}
		correctValue := Num2StrF(PMIDPOINTDIST);
	END ELSE IF NOT matchPoint AND matchField THEN BEGIN
		{Point correct, set value from control point}
		correctValue := Num2StrF(PCONTROLPOINT02X);
	END ELSE IF NOT matchPoint AND NOT matchField THEN BEGIN
		{Neither correct, set value from control point}
		correctValue := Num2StrF(PCONTROLPOINT02X);
	END;
	IF correctValue<>'' THEN BEGIN
		SetRField(h_Obj,s_ObjName,'ControlPoint02X',correctValue);
		SetRField(h_Obj,s_ObjName,'MidpointDist',correctValue);
		SetRField(h_Obj,s_ObjName,'__StoreMidpointDist',correctValue);
		ResetObject(h_Obj);
	END;
END;

PROCEDURE Resolve_Endpoint_Conflict;
VAR
	matchPoint,matchField : BOOLEAN;
	correctValue          : STRING;
BEGIN
	matchPoint := (P__STOREENDDIST = Num2StrF(PCONTROLPOINT03X));
	matchField := (P__STOREENDDIST = Num2StrF(PENDDIST));
	correctValue := '';
	IF matchPoint AND NOT matchField THEN BEGIN
		{Field correct, set value from field}
		correctValue := Num2StrF(PENDDIST);
	END ELSE IF NOT matchPoint AND matchField THEN BEGIN
		{Point correct, set value from control point}
		correctValue := Num2StrF(PCONTROLPOINT03X);
	END ELSE IF NOT matchPoint AND NOT matchField THEN BEGIN
		{Neither correct, set value from control point}
		correctValue := Num2StrF(PCONTROLPOINT03X);
	END;
	IF correctValue<>'' THEN BEGIN
		SetRField(h_Obj,s_ObjName,'ControlPoint03X',correctValue);
		SetRField(h_Obj,s_ObjName,'EndDist',correctValue);
		SetRField(h_Obj,s_ObjName,'__StoreEndDist',correctValue);
		ResetObject(h_Obj);
	END;
END;

FUNCTION Resolve_Begin_Conflict : BOOLEAN;
BEGIN
	IF (PCONTROLPOINT01X <> 0) OR (PCONTROLPOINT01Y <> 0) THEN BEGIN
		HMove(h_Obj,PCONTROLPOINT01X,PCONTROLPOINT01Y);
		SetRField(h_Obj,s_ObjName,'ControlPoint01X','0');
		SetRField(h_Obj,s_ObjName,'ControlPoint01Y','0');
		SetRField(
				h_Obj,s_ObjName,'ControlPoint02X',
				Num2StrF(PCONTROLPOINT02X-PCONTROLPOINT01X)
				);
		SetRField(h_Obj,s_ObjName,'ControlPoint02Y',
				Num2StrF(PCONTROLPOINT02Y-PCONTROLPOINT01Y)
				);
		SetRField(
				h_Obj,s_ObjName,'ControlPoint03X',
				Num2StrF(PCONTROLPOINT03X-PCONTROLPOINT01X)
				);
		SetRField(h_Obj,s_ObjName,'ControlPoint03Y',
				Num2StrF(PCONTROLPOINT03Y-PCONTROLPOINT01Y)
				);
		ResetObject(h_Obj);
		Resolve_Begin_Conflict := TRUE;
	END ELSE Resolve_Begin_Conflict := FALSE;
END;

PROCEDURE Draw_Line(p1,p2,p3 : POINT; cstyle : INTEGER; csize : REAL);
BEGIN
	MoveTo(0,0);
	BeginPoly;
	{Start point}
	Add2DVertex(p1.X,p1.Y,0,0);
	{Corner1}
	Add2DVertex(p2.X,p1.Y,cstyle,Abs(csize));
	{Corner2}
	Add2DVertex(p2.X,p3.Y,cstyle,Abs(csize));
	{End point}
	Add2DVertex(p3.X,p3.Y,0,0);
	EndPoly;
END;

{Sets Object Begin and End Markers to custom, 'Dot' OR 'Arrow'}
PROCEDURE Set_Markers_Cust (h : HANDLE;sBeg:STRING;sEnd:STRING);
VAR b     : BOOLEAN;
	ActLS : REAL;
BEGIN
	ActLS := GetLScale(Find_Layer(h_Obj));
	IF sBeg = 'Dot' THEN {Dot}
		b := SetObjBeginningMarker(h,2,0,1/ActLS,1/ActLS,0,0,TRUE)
	ELSE IF sBeg = 'Arrow' THEN {Arrow}
		b := SetObjBeginningMarker(h,2176,15,3/ActLS,2/ActLS,0,0,TRUE);
	IF sEnd = 'Dot' THEN {Dot}
		b := SetObjEndMarker(h,2,0,1/ActLS,1/ActLS,0,0,TRUE)
	ELSE IF sEnd = 'Arrow' THEN {Arrow}
		b := SetObjEndMarker(h,2176,15,3/ActLS,2/ActLS,0,0,TRUE);
END;


{====================================}
{------------- < MAIN > -------------}
{====================================}

{// Retrieve plug-in object information //}
BEGIN IF GetCustomObjectInfo(s_ObjName,h_Obj,h_ObjRecord,h_ObjWall) THEN BEGIN
	Set_Version_Info('0 . 4');
	Use_PIO_Text_Attributes(h_Obj);
	SetParameterVisibility(h_Obj,'ControlPoint01X',FALSE);
	SetParameterVisibility(h_Obj,'ControlPoint01Y',FALSE);
	SetParameterVisibility(h_Obj,'ControlPoint02X',FALSE);
	SetParameterVisibility(h_Obj,'ControlPoint02Y',FALSE);
	SetParameterVisibility(h_Obj,'ControlPoint03X',FALSE);
	SetParameterVisibility(h_Obj,'ControlPoint03Y',FALSE);

	{===== Parameter checking =====}
	IF NOT Resolve_Begin_Conflict THEN BEGIN
		Resolve_MidPoint_Conflict;
		Resolve_Endpoint_Conflict;
	END;

	{===== Variable Assignment =====}
	p_Start.X := 0;
	p_Start.Y := 0;
	p_End.X := PCONTROLPOINT03X;
	p_End.Y := PCONTROLPOINT03Y;
	p_Midpoint.X := PCONTROLPOINT02X;
	p_Midpoint.Y := (p_End.Y-p_Start.Y)/2;
	IF PCORNERS='Square' THEN BEGIN
		i_CornerStyle := 0;
		SetParameterVisibility(h_Obj,'RoundRadius',FALSE);
	END;
	IF PCORNERS='Rounded' THEN BEGIN
		i_CornerStyle := 3;
		SetParameterVisibility(h_Obj,'RoundRadius',TRUE);
	END;

	IF PBEGDUPSIZE = 'Regular' THEN i_BegDupSize := RegularH
	ELSE IF PBEGDUPSIZE = 'Small' THEN i_BegDupSize := SmallH
	ELSE IF PBEGDUPSIZE = 'Micro' THEN i_BegDupSize := MicroH;

	IF PENDDUPSIZE = 'Regular' THEN i_EndDupSize := RegularH
	ELSE IF PENDDUPSIZE = 'Small' THEN i_EndDupSize := SmallH
	ELSE IF PENDDUPSIZE = 'Micro' THEN i_EndDupSize := MicroH;

	{// Corner Sizing //}
	r_CornerSize := PROUNDRADIUS;
	IF Abs(p_End.Y)<(r_CornerSize*2)
		THEN r_CornerSize := Abs(p_End.Y/2);
	IF Abs(p_Midpoint.X)<(r_CornerSize)
		THEN r_CornerSize := Abs(p_Midpoint.X/2);
	IF Abs(p_End.X-p_Midpoint.X)<(r_CornerSize)
		THEN r_CornerSize := Abs((p_End.X-p_Midpoint.X)/2);
	{ IF p_End.Y<p_Start.Y THEN r_CornerSize := -r_CornerSize; }

	{===== Draw Poly =====}
	PushAttrs; {((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((}
	FillPat(0);
	Draw_Line(p_Start,p_Midpoint,p_End,i_CornerStyle,r_CornerSize);
	h_Poly := LNewObj;

	{===== Set poly markers =====}
	IF PUSEBEGINMARK THEN Set_Markers_Cust(h_Poly,'Dot','NA');
	IF PUSEENDMARK THEN Set_Markers_Cust(h_Poly,'NA','Arrow');

	{ SetFPat(h_Poly,0); }

	IF PNUMBEGINDUP > 0 THEN FOR i_Counter := 1 TO PNUMBEGINDUP DO BEGIN
		BeginPoly;
		Add2DVertex(p_Start.X,p_Start.Y+(i_Counter*i_BegDupSize),0,0);
		Add2DVertex(p_Start.X+3,p_Start.Y+(i_Counter*i_BegDupSize),
					i_CornerStyle,3);
		Add2DVertex(p_Start.X+3,p_Start.Y,i_CornerStyle,3);
		IF p_Midpoint.X > (p_Start.X+3) THEN
			Add2DVertex(p_Midpoint.X-r_CornerSize,p_Start.Y,0,0)
		ELSE Add2DVertex(p_Midpoint.X,p_Midpoint.Y,0,0);
		EndPoly;
		IF PUSEBEGINMARK THEN Set_Markers_Cust(LNewObj,'Dot','NA');

	END ELSE FOR i_Counter := -1 DOWNTO PNUMBEGINDUP DO BEGIN
		BeginPoly;
		Add2DVertex(p_Start.X,p_Start.Y+(i_Counter*i_BegDupSize),0,0);
		Add2DVertex(p_Start.X+3,p_Start.Y+(i_Counter*i_BegDupSize),
					i_CornerStyle,3);
		Add2DVertex(p_Start.X+3,p_Start.Y,i_CornerStyle,3);
		IF p_Midpoint.X > (p_Start.X+3) THEN
			Add2DVertex(p_Midpoint.X-r_CornerSize,p_Start.Y,0,0)
		ELSE Add2DVertex(p_Midpoint.X,p_Midpoint.Y,0,0);
		EndPoly;
		IF PUSEBEGINMARK THEN Set_Markers_Cust(LNewObj,'Dot','NA');
	END;

	IF PNUMENDDUP > 0 THEN FOR i_Counter := 1 TO PNUMENDDUP DO BEGIN
		BeginPoly;
		Add2DVertex(p_End.X,p_End.Y+(i_Counter*i_EndDupSize),0,0);
		Add2DVertex(p_End.X-3,p_End.Y+(i_Counter*i_EndDupSize),
				i_CornerStyle,3);
		Add2DVertex(p_End.X-3,p_End.Y,i_CornerStyle,3);
		IF p_Midpoint.X < (p_End.X+3) THEN
			Add2DVertex(p_Midpoint.X+r_CornerSize,p_End.Y,0,0)
		ELSE Add2DVertex(p_Midpoint.X,p_Midpoint.Y,0,0);
		EndPoly;
		IF PUSEENDMARK THEN Set_Markers_Cust(LNewObj,'Arrow','NA');

	END ELSE FOR i_Counter := -1 DOWNTO PNUMENDDUP DO BEGIN
		BeginPoly;
		Add2DVertex(p_End.X,p_End.Y+(i_Counter*i_EndDupSize),0,0);
		Add2DVertex(p_End.X-3,p_End.Y+(i_Counter*i_EndDupSize),
				i_CornerStyle,3);
		Add2DVertex(p_End.X-3,p_End.Y,i_CornerStyle,3);
		IF p_Midpoint.X < (p_End.X+3) THEN
			Add2DVertex(p_Midpoint.X+r_CornerSize,p_End.Y,0,0)
		ELSE Add2DVertex(p_Midpoint.X,p_Midpoint.Y,0,0);
		EndPoly;
		IF PUSEENDMARK THEN Set_Markers_Cust(LNewObj,'Arrow','NA');
	END;




	PopAttrs; {))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))}

	SetRField(
			h_Obj, s_ObjName, 'ControlPoint02Y',
			Num2StrF((p_End.Y-p_Start.Y)/2)
			);

END; END; Run(SBD_Line);
