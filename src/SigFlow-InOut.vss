{//////////////////////////////////////////////////////////////////////////////
//  Developed by John Salutz, (c) 2020. Please share freely.
//
//  AudioSys In-Out is a point based object for drawing input/output slots in
//  an audio signal flow diagram.
//////////////////////////////////////////////////////////////////////////////}

{//////////////////////////////////////////////////////////////////////////////
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//  <https://www.gnu.org/licenses/>
//////////////////////////////////////////////////////////////////////////////}

PROCEDURE SysFlow_InOut;

CONST
	RGBmax = 65535; {Max value for setting RGB colors in VS fuctions}

VAR
	{Standard variables}
	s_ObjName                                               : STRING;
	h_Obj,h_ObjRecord,h_ObjWall                             : HANDLE;
	b_Result                                                : BOOLEAN;
	i_Counter                                               : INTEGER;
	{Script specific variables}
	h_Poly                                                  : HANDLE;
	p_Origin,p_End,p_Leader,p_TextOffset                    : POINT;
	r_TextScaler,r_TextLarge,r_TextSmall                    : REAL;

{===== LOCAL FUNCTION DECLARATIONS =====}

{// Sets Version info parameter //}
PROCEDURE Set_Version_Info(s : STRING);
BEGIN
	SetRField(h_Obj,s_ObjName,'ver',s);
END;

{// Sets the specified text object to use the attributes of PIO //}
PROCEDURE Use_PIO_Text_Attributes (h : HANDLE);
BEGIN
	SetObjectVariableBoolean(h,800,True);
END;

{// Sets Background Fore and Back as White to Black, percentage set by 'r',
	format 0=White, 0.1 thru 0.9=10% to 90%, 1=Black //}
PROCEDURE Set_Background_WtoB (h : HANDLE; r : REAL);
VAR i : LONGINT;
BEGIN
	IF r<0 THEN r:=0;
	IF r>1 THEN r:=1;
	i := Trunc(RGBmax*(1-r));
	SetFillBack(h, i, i, i);
	SetFillFore(h, i, i, i);
	SetFPat(h, 1); {Blank pattern}
END;

{// Sets Pen Fore and Back as White to Black, percentage set by 'r',
	format 0=White, 0.1 thru 0.9=10% to 90%, 1=Black //}
PROCEDURE Set_Pen_WtoB (h : HANDLE; r : REAL);
VAR i : LONGINT;
BEGIN
	IF r<0 THEN r:=0;
	IF r>1 THEN r:=1;
	i := Trunc(RGBmax*(1-r));
	SetPenFore(h, i, i, i);
	SetPenBack(h, i, i, i);
	SetLSN(h,2); {Solid pattern}
END;

PROCEDURE Set_Tight_TextFill (h : HANDLE;b : BOOLEAN);
BEGIN
	SetObjectVariableBoolean(h,684,b);
END;

PROCEDURE Set_Text_HardBold (h : HANDLE);
BEGIN
	SetTextStyle(h,0,GetTextLength(h),0);
	SetTextStyle(h,0,GetTextLength(h),1);
END;

FUNCTION Find_Layer (obj : HANDLE) : HANDLE;
BEGIN
	IF GetLayer(obj) = NIL THEN ResetObject(obj)
	ELSE Find_Layer := GetLayer(obj);
END;

FUNCTION Get_Zcoor(h : HANDLE) : REAL;
VAR
	x,y,z : REAL;
BEGIN
	GetSymLoc3D(h_Obj,x,y,z);
	Get_Zcoor := z;
END;

{Sets Object Begin and End Markers to custom, 'Dot' OR 'Arrow'}
PROCEDURE Set_Markers_Cust (h : HANDLE;sBeg:STRING;sEnd:STRING);
VAR b	  : BOOLEAN;
	ActLS : REAL;
BEGIN
	ActLS := GetLScale(Find_Layer(h_Obj));
	IF sBeg = 'Dot' THEN {Dot}
		b := SetObjBeginningMarker(h,2,0,1/ActLS,1/ActLS,0,0,TRUE)
	ELSE IF sBeg = 'Arrow' THEN {Arrow}
		b := SetObjBeginningMarker(h,2176,15,3/ActLS,2/ActLS,0,0,TRUE);
	IF sEnd	 = 'Dot' THEN {Dot}
		b := SetObjEndMarker(h,2,0,1/ActLS,1/ActLS,0,0,TRUE)
	ELSE IF sEnd = 'Arrow' THEN {Arrow}
		b := SetObjEndMarker(h,2176,15,3/ActLS,2/ActLS,0,0,TRUE);
END;

PROCEDURE From_Back_Set_Pen (source : HANDLE; target : HANDLE);
VAR r,g,b : LONGINT;
BEGIN
	GetFillBack(source,r,g,b);
	SetPenFore(target,r,g,b);
END;

{====================================}
{------------- < MAIN > -------------}
{====================================}

{// Retrieve plug-in object information //}
BEGIN IF GetCustomObjectInfo(s_ObjName,h_Obj,h_ObjRecord,h_ObjWall) THEN BEGIN
	Set_Version_Info('0 . 3');
	Use_PIO_Text_Attributes(h_Obj);
	{===== Parameter Limits =====}
	{===== Variable Setup =====}
	PushAttrs; {Attrs01}
	FillPat(1);
	FillBack(RGBmax,RGBmax,RGBmax);
	PenPatN(2);
	TextVerticalAlign(3);
	TextFace([]);
	r_TextScaler := 48/GetLScale(Find_Layer(h_Obj));
	PenFore(0,0,0);
	PenBack(0,0,0);
	p_Origin.X := 0;
	p_Leader.Y := 0;
	p_TextOffset.X := 5/8;

	{===== Setup Size =====}
	IF PSIZE = 'Regular' THEN BEGIN
		p_Origin.Y := 6;
		r_TextLarge := 8*r_TextScaler;
		r_TextSmall := 6*r_TextScaler;
		p_TextOffset.Y := 5/8;
	END ELSE IF PSIZE = 'Small' THEN BEGIN
		p_Origin.Y := 4.5;
		r_TextLarge := 7*r_TextScaler;
		r_TextSmall := 4*r_TextScaler;
		p_TextOffset.Y := 5/16;
	END ELSE IF PSIZE = 'Smaller' THEN BEGIN
		p_Origin.Y := 3;
		r_TextLarge := 6*r_TextScaler;
		r_TextSmall := 3.5*r_TextScaler;
		p_TextOffset.Y := 5/32;
	END;
	p_End.Y := -p_Origin.Y;

	{===== Setup Type =====}
	IF PTYPE = 'Input' THEN BEGIN
		p_End.X := 24;
		p_Leader.X := -9;
		TextJust(1);
		TextOrigin(1,0);
	END ELSE IF PTYPE = 'Output' THEN BEGIN
		p_End.X := -24;
		p_Leader.X := 9;
		TextJust(3);
		TextOrigin(-1,0);
		p_TextOffset.X := -p_TextOffset.X;
	END ELSE IF PTYPE = 'Thru' THEN BEGIN
		TextJust(2);
		TextOrigin(0,0);
		p_Leader.X := -21;
		p_Origin.X := -12;
		p_End.X := 12;
		p_TextOffset.X := -p_TextOffset.X-12;
	END;

	{===== Draw Text =====}
	{// Draw ID/Number Text //}
	TextSize(r_TextLarge);
	IF PPREFIX <> '' THEN CreateText(Concat(PPREFIX,' ',PIDNUM))
	ELSE CreateText(PIDNUM);


	PushAttrs; {===== Attrs02 =====}

	{// Draw Routing Text //}
	NameClass(PCLASSROUT);
	IF PTYPE = 'Input' THEN TextJust(3)
	ELSE IF (PTYPE = 'Output') OR (PTYPE = 'Thru') THEN TextJust(1);
	TextVerticalAlign(1);
	PenFore(RGBmax/2,RGBmax/2,RGBmax/2);
	PenBack(RGBmax/2,RGBmax/2,RGBmax/2);
	TextOrigin(-p_TextOffset.X,-p_TextOffset.Y);
	TextSize(r_TextSmall-1);
	IF PROUTING <> '' THEN CreateText(Concat(UniChr(187),PROUTING));

	{// Draw Purpose Text //}
	IF PTYPE = 'Thru' THEN TextJust(3);
	TextVerticalAlign(5);
	TextSize(r_TextSmall);
	IF PTYPE = 'Thru' THEN TextOrigin(p_TextOffset.X,p_TextOffset.Y)
	ELSE TextOrigin(-p_TextOffset.X,p_TextOffset.Y);
	TextFace([Italic]);
	NameClass(PCLASSPURP);
	CreateText(PPURPOSE);

	PopAttrs; {===== Attrs02 =====}


	{===== Draw Poly =====}
	BeginPoly;
	Add2DVertex(p_Leader.X,p_Leader.Y,0,0);
	Add2DVertex(p_Origin.X,0,0,0);
	Add2DVertex(p_Origin.X,p_Origin.Y,0,0);
	Add2DVertex(p_End.X,p_Origin.Y,0,0);
	IF PTYPE = 'Thru' THEN BEGIN
		Add2DVertex(p_End.X,0,0,0);
		Add2DVertex(-p_Leader.X,p_Leader.Y,0,0);
		Add2DVertex(p_End.X,0,0,0);
	END;
	Add2DVertex(p_End.X,p_End.Y,0,0);
	Add2DVertex(p_Origin.X,p_End.Y,0,0);
	Add2DVertex(p_Origin.X,0,0,0);
	EndPoly;
	HMoveBackward(LNewObj,TRUE);

	PopAttrs; {Attrs01}
END; END; Run(SysFlow_InOut);
